using System;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace SourceGenerators;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class EntityComponentGenerator : IIncrementalGenerator {
    private const string Namespace = "NetGL.ECS";
    private const string AttributeName = "EntityComponentAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeName} : System.Attribute
    {{
    }}
}}";

    static readonly DiagnosticDescriptor info_message = new DiagnosticDescriptor(
        id: "JUBR00",
        title: "Info",
        messageFormat: "{0}",
        category: "SourceGenerator",
        defaultSeverity: DiagnosticSeverity.Info, // Or DiagnosticSeverity.Info based on your needs
        isEnabledByDefault: true);

    static readonly DiagnosticDescriptor warning_message = new DiagnosticDescriptor(
        id: "JUBR01",
        title: "Warning",
        messageFormat: "{0}",
        category: "SourceGenerator",
        defaultSeverity: DiagnosticSeverity.Warning, // Or DiagnosticSeverity.Info based on your needs
        isEnabledByDefault: true);

    static readonly DiagnosticDescriptor error_message = new DiagnosticDescriptor(
        id: "JUBR02",
        title: "Error",
        messageFormat: "{0}",
        category: "SourceGenerator",
        defaultSeverity: DiagnosticSeverity.Error, // Or DiagnosticSeverity.Info based on your needs
        isEnabledByDefault: true);

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        context.RegisterSourceOutput(
            context.CompilationProvider,
            (spc, _) => {
                var diagnostic = Diagnostic.Create(info_message, Location.None, "Creating ECS classes");
                spc.ReportDiagnostic(diagnostic);
            });

        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the attribute and maps syntax context to the specific node type
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax, bool reportAttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context) {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        // Go through all attributes of the class.
        foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
            Console.WriteLine(attributeSyntax.ToString());
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            string attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Report] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations) {
        // Go through all filtered class declarations.

        foreach (var classDeclarationSyntax in classDeclarations) {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;

            var diagnostic = Diagnostic.Create(warning_message, Location.None,
                $"Creating ECS classes: {namespaceName}.{className}");
            context.ReportDiagnostic(diagnostic);

            StringBuilder code = new();
            code.Append($"namespace {namespaceName}; ");
            code.Append($"public static class {className}Component {{");

            // Go through all class members with a particular type (property) to generate method lines.
            foreach (var ctor in classSymbol.Constructors) {
                diagnostic = Diagnostic.Create(warning_message, Location.None,
                    $"Creating ECS classes: {namespaceName}.{className}.{ctor.Name}");
                context.ReportDiagnostic(diagnostic);

                code.Append($"public static {className} add_{className.ToLower()}(this Entity entity, ");
                var code_create = $"var component = new {className}(entity, \"{className}\", ";
                foreach (var param in ctor.Parameters) {
                    diagnostic = Diagnostic.Create(warning_message, Location.None,
                        $"{namespaceName}.{className}.{ctor.Name} {param.Type.ToDisplayString()} {param.Name}");
                    context.ReportDiagnostic(diagnostic);

                    if (param.Name != "entity") {
                        code.Append($"{param.Type.ToDisplayString()} {param.Name}, ");
                        code_create += $"{param.Name}, ";
                    }
                }

                code.Append(") {");
                code.Append(code_create);
                code.Append(")}");
            }

            code.Append("}");

            var code_str = code.ToString();
            code_str = code_str.Replace(", )", ")");
            code_str = code_str.Replace("System.", "");

            diagnostic = Diagnostic.Create(warning_message, Location.None, code_str);
            context.ReportDiagnostic(diagnostic);

            /*.OfType<IPropertySymbol>()
                .Select(p =>
                    $@"        yield return $""{p.Name}:{{this.{p.Name}}}"";"); // e.g. yield return $"Id:{this.Id}";

            // Build up the source code
            var code = $@"// <auto-generated/>

using System;
using System.Collections.Generic;

namespace {namespaceName};

partial class {className}
{{
    public IEnumerable<string> Report()
    {{
{string.Join("\n", methodBody)}
    }}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    */
        }
    }
}